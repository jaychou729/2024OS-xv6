# 1. Speed up system calls 

##　1.1 实验目的

使用页表机制加速系统调用：一些操作系统（如 Linux）通过在用户空间和内核之间共享只读区域中的数据来加快某些系统调用的速度。操作系统不会将内核的数据结构复制到用户空间，而是直接将存放该数据结构的页通过页表 的机制映射到用户空间的对应位置，从而免去了复制的开销，提高了系统的性能。本实验旨在学习如何在页表中插入映射，首先需要在 xv6 中的 `getpid()` 系统调用中实现这一优化。

通过在用户空间和内核之间共享一个只读区域中的数据，来加速特定的系统调用。具体而言，通过在进程创建时映射一个只读页，将一个 `struct usyscall` 结构放置在该页的开头，该结构会存储当前进程的 `PID`。这将使得在执行某些系统调用时，不需要进行用户空间和内核之间的频繁切换，从而提高系统调用的性能。

## 1.2 实验步骤

本次实验需切换到` pgtbl `分支
```bash
  $ git fetch
  $ git checkout pgtbl
  $ make clean
  ```

  ![lab2](./Resource/lab3-1.1.png)

  1.在` kernel/proc.h` 的`proc` 结构体中添加指针来保存这个共享页面的地址：

 ![lab2](./Resource/lab3-1.2.png)

 2.在`kernel/memlayout.h`中完成映射页面工作

 ![lab2](./Resource/lab3-1.3.png)

 3. 在` kernel/proc.c `的` allocproc() `函数中完成共享页的分配和初始化：

 ![lab2](./Resource/lab3-1.4.png)

 4. 在` kernel/proc.c `的` proc_ pagetable(struct proc *p) `完成为新创建的进程分配页面的函数。页面映射时，需要设定其权限为只读，故权限位为` PTE_R | PTE_U `：

  ![lab2](./Resource/lab3-1.5.png)

  5. 在` kernel/proc.c `的` freeproc()` 完成在进程结束后释放分配的页面的函数：

  ![lab2](./Resource/lab3-1.6.png)

  6. 在` kernel/proc.c `的` proc_freepagetable(pagetable_t pagetable, uint64 sz) `完成释放页表中对应的页表项的函数：

![lab2](./Resource/lab3-1.7.png)

7. 利用`make qemu`指令运行`xv6`：

8. 在命令行中输入`pgtbltest`:

![lab2](./Resource/lab3-1.8.png)

9. 在终端里运行` ./grade-lab-pgtbl ugetpid `可进行评分：
![lab2](./Resource/lab3-1.9.png)

## 1.3 实验中遇到的问题和解决方法
页面映射问题： 在进行页面映射时，我遇到了页表相关的映射问题，导致系统调用执行失败或崩溃，比如我在运行的时候得到了下面这样的报错：
```bash
xv6 kernel is booting

hart 2 starting
hart 1 starting
panic: freewalk: leaf
```
* 解决方法： 通过仔细阅读` xv6 `的页表管理部分代码，我发现除了需要确保在` allocproc() `和` freeproc() `中正确创建和释放页表映射，还需要及时取消映射，因为在` pagetable `中任然存在我们之前的` PTE `映射。我们需要在` kernel/proc.c `的 `proc_freepagetable` 函数中对其取消映射。
```c
uvmunmap(pagetable, USYSCALL, 1, 0);
```
* 权限问题： 在页面权限的设置上，我遇到了一些问题：如果权限设置不正确，可能导致用户空间尝试写入只读页，导致错误或崩溃。如`proc_pagetable(struct proc *p) `中映射` PTE `时的权限应该为 `PTE_R | PTE_U `而不是` PTE_R | PTE_U | PTE_W`。

解决方法： 因为在` xv6 `的设计中，用户程序不应该直接写入代码或数据段，这是由操作系统负责的。因此，在将这些代码和数据映射到用户页表时，不应该使用可写权限，而只需要可读权限 `(PTE_R) 和用户权限 (PTE_U) 即可。在页面映射时，确保设置权限位为只读，以防止用户空间进行写操作。

## 实验心得
通过本次实验，首先我看到了性能优化的重要性，这给了我很大的启示：通过将系统调用的相关数据放在只读页中，以减少内核和用户空间之间的数据传输次数，从而加速系统调用的执行。

此外这个实验使我更深入地理解了系统调用的工作原理以及它们是如何在用户空间和内核空间之间进行通信的。这为您提供了更清晰的操作系统工作流程的认识。通过在每个进程的页表中插入只读页，掌握操作页表的方法，从而实现用户空间与内核空间之间的数据共享。尽管在实验过程中遇到了不少问题，但是这让我对映射与回收、权限授予等有了更深刻的理解。

# 2. Print a page table

## 2.1 实验目的
打印页表：深入理解` RISC-V `页表的结构和内容，并提供一个接受`pagetable_t `参数，打印页表的函数` vmprint()` 。通过这个实验，实现可视化页表的布局，了解页表的层次结构以及如何将虚拟地址映射到物理地址。

## 2.2 实验步骤
1. 在 `kernel/exec.c` 的 `exec()` 函数中找到 `return argc`; 之前的位置，插入条件语句 `if(p->pid==1) vmprint(p->pagetable);`，以在执行 `init `进程时打印第一个进程的页表。

![lab2](./Resource/lab3-2.1.png)

2. 在 `kernel/defs.h` 中定义 vmprint 的原型，以便在 exec.c 中调用：

![lab2](./Resource/lab3-2.2.png)

3. 仿照`kernel/vm.c`的`freewalk()`函数的写法，写`vmprintwalk()`函数，`main`函数调用`exit()`以退出程序：

通过递归的方式逐层释放页表。
![lab2](./Resource/lab3-2.3.png)

4. 保存后在终端里执行make qemu编译运行xv6（按照一定的格式打印出每个 PTE 的索引、PTE 的 16 进制表示和从 PTE 中提取的物理地址）：
![lab2](./Resource/lab3-2.4.png)

## 2.3 实验中遇到的问题和解决方法
* 递归错误： 在递归地遍历页表时，起初在递归的设计上，思路还不太清晰，后来参考了freewalk函数的形式，让我对递归遍历的逻辑有了更好的理解。
* 格式化输出问题： 我在格式化输出的语法上出现了一些错误。后来我结合控制台调试，使用 %p 格式化符正确地打印了 64 位的十六进制 PTE 和物理地址。
* 页表层次理解： 在理解页表的层次结构时，可能显得过于抽象，但通过观察源码、结合课程教材中的图 3-4和解释 vmprint() 输出的页表内容，我可以更清晰地了解每个级别的页表是如何映射虚拟地址到物理地址的。

## 2.4 实验心得
通过本次实验，我深入了解了操作系统内核的页表结构，并学会了遍历页表并打印出其中的信息。
`vmprint `的输出：第一行为输入的参数，接着输出` valid `的 `PTE` 以及指向的 `pa`（物理地址）。第 0 页包含指向其他页表页的指针，以构建页表的层次结构；第 2 页实际上是指向第 1 页的 `PTE`（位于第 1 页的索引 2 处）。第 1 页是第一个第 1 级页表页，它包含指向第 2 级页表页的 `PTE`。所以第 2 页中的 `PTE` 包含指向下一级页表页（第 2 级页表页）的物理地址。倒数第三页是指向用户栈的 PTE，它的权限通常是可读、可写和用户权限。用户栈用于存储进程在用户模式下调用函数时的局部变量和临时数据。

# 3 Detecting which pages have been accessed
## 3.1 实验目的
追踪被访问的页：一些垃圾回收器（一种自动内存管理形式）可以从哪些页面已被访问（读取或写入）的信息中获益。在实验中，添加一项`pgaccess()`系统调用检测哪些页面已被访问，通过检查` RISC-V `页表中的访问位来检测并向用户空间报告这些信息。每当 `RISC-V` 硬件走页器解决 `TLB` 未命中问题时，都会在 `PTE` 中标记这些位。

`pgaccess()`用于报告哪些页面已被访问。系统调用需要三个参数。首先，它需要第一个要检查的用户页面的起始虚拟地址。其次，它接受要检查的页面数。最后，它需要一个缓冲区的用户地址，以便将结果存储到位掩码（一种数据结构，每页使用一位，其中第一页对应的是最小有效位）中。

## 3.2 实验步骤
1. 在` kernel/riscv.h `中定义一个` PTE_A`，其为 `Risc V` 定义的 `access bit`，设定访问位;
```c
#define PTE_A (1L << 6)
```

![lab2](./Resource/lab3-3.1.png)
2. 在`defs.h`中声明`walk`；

![lab2](./Resource/lab3-3.2.png)

3. 在1 kernel/sysproc.c 1中实现` sys_pgaccess()`， 获取系统调用参数

![lab2](./Resource/lab3-3.3.png)

4. 保存后在终端里执行`make qemu`编译运行`xv6`；

5. 在命令行中输入`pgtbltest`，出现 :

![lab2](./Resource/lab3-3.4.png)

## 3.3 实验中遇到的问题和解决方法
在实验中有一个主要的步骤——“清除 PTE_A 访问位”，检查之后我们需要对 PTE_A 位进行清零操作。如何将一个二进制值的指定位设置为指定的值？这个问题困扰着我。经过一番搜索学习，我找到了一个实用的公式：

公式：`x = ((x&(1 << n)) ^ x) ^ (a << n)`。 x 为原值，n 为第 n 个值，a 为想要设置的值（0或1）。

首先 `(x&(1 << n))` 的值为：保留第 n 位原来的值，其他位置零。再将此值与原值 x 异或，得到一个值：除了第 n 个值为零，其他位置为原值。（这是因为，与 0 异或的那一位为原值，与相同值异或的那一位为 0）。然后此时，再与 (a << n) 异或，将第 n 位设置为 a （这是因为与 0 异或为其本身）。
```bash
原值                1 0 | 1 | 0    x
其他位为0            0 0 | 1 | 0    x & ( 1 << n )
待设置的值           0 0 | 0 | 0    a << n
将 1 和 2 异或得到   1 0 | 0 | 0     x & ( 1 << n ) ^ x
将 3 和 4 异或得到   1 0 | 0 | 0     ((x&(1 << n)) ^ x) ^ (a << n)
```

## 3.4 实验心得
通过本次实验，我学会了如何使用用户空间缓冲区和内核空间缓冲区之间的数据传输。

实现` pgaccess() `系统调用的过程中，我深入了解了` RISC-V `页表中的访问位 `PTE_A`，并学会了如何在内核中清除位。

通过实验初步了解了 `RISC-V `中最常用的 `Sv-39 （Page-Based 39-bit Virtual-Memory System ）`分页机制

![lab2](./Resource/lab3-3.5.png)

上图即`RISC-V `手册中关于`Sv-39` 的总结。参考对应上图中的 Figure 4.16 ，顾名思义，`Sv- 39` 的支持 39 位的虚拟地址，即 64 位的低 39 位是有效的，高位均为第 38 位的值；其一个页面大小为 4KB（必须边界对齐，即页面起始地址的低 12 位必须均为 0 ），故整个 39 位的地址的 0 到 11 位是页内偏移，在地址变换时不发生变化。

除去页内偏移外，剩余高的 27 位被等分为了 3 段，每段各 9 位；每一段对应各级页表， 故` Sv-39` 是一个三级页表的系统（比 x86 架构的 32 位二级页表要多一级），而每段的 9 位的 VPN （虚存页面编号）对应该级页表中的项，即每一个页表中有 29 = 512 项，这与页面大小是匹配的，因为每个页表项为 64 位（见上图中的 Figure 4.18 ），即 8 Byte ，故整个页表的大小恰好为 4KB ，即一页的大小。

在 Sv-39 中，物理地址的格式对应上图中的 Figure 4.17 ，与虚拟地址类似，页面大小为4KB 且边界对齐；除了低位的 12 位页内偏移外，高位为物理的页号（共 44 位物理页号）。对于页表项，高位的未使用的 54 到 63 位始终置 0 ，而后是 44 位物理页号，而后的第 9 位和第8 位是供操作系统自定义使用的，而后的第 0 到第 7 位是该页面的状态位、权限设置和属性等。具体的 0 到 7 位的含义如下：

第 7 位，`Dirty bit `，对应的页面被写入后会被硬件置为 1 ，可被操作系统置为 0

第 6 位，`Access bit` ，对应的页面被访问后会被硬件置为 1 ，可被操作系统置为 0

第 5 位，`Global bit` ，其为 1 表示该页表项的映射对所有的内存空间均有效

第 4 位到第 1 位，`User/Read/Write/eXecute bit`，用于控制页面的权限，由操作系统设置第 0 位，`Valid bit`，页表项的有效位

在使用`Sv-39` 分页机制进行内存地址转换时，根页表的物理页面号 `PPN` 会被存储在`SATP` 寄存器的`PPN` 号的区间内，且 `SATP` 寄存器的`MODE` 段（分页模式）和 `ASID` 段（地址空间） 都被设为进程对应的值。某个指令访问某个虚拟地址时，处理器会：

读取 `SATP` 寄存器的 `PPN` 对应的页表根页面，

然后依次沿着各级 `VPN` （虚存页面编号）找到虚拟地址对应的页表项，

检查权限无误后，根据指令的操作设置该页表项的`Dirty/Access `位，

并且用该页表项的 `PPN` 与指令的页内偏移拼接，得到物理地址，

然后执行指令的操作。

## 实验检验得分
![lab2](./Resource/lab3-2.5.png)

